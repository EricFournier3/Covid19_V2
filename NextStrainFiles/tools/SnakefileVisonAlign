from os import environ
from packaging import version
from socket import getfqdn
from getpass import getuser
from snakemake.logging import logger
import sys
import stat
import shutil
from shutil import which
import logging
import datetime
from datetime import timedelta
import os
import pandas as pd
import subprocess
from Bio import AlignIO


logging.basicConfig(level=logging.DEBUG)


#
# Verify that required versions of dependencies are installed.
#
MIN_AUGUR_VERSION = "7.0.2"

try:
    from augur.__version__ import __version__ as augur_version
except ModuleNotFoundError:
    logger.error("ERROR: Could not find augur. Follow installation instructions at https://nextstrain.org/docs/ and try again.")
    sys.exit(1)

if version.parse(augur_version) < version.parse(MIN_AUGUR_VERSION):
    logger.error("ERROR: Found version '%s' of augur, but version '%s' or greater is required" % (augur_version, MIN_AUGUR_VERSION))
    sys.exit(1)

SHELL_COMMANDS_NEEDED = ["augur", "iqtree", "mafft"]
for sh_cmd in SHELL_COMMANDS_NEEDED:
    if not which(sh_cmd):
        logger.error(f"ERROR: `{sh_cmd}` is not available as a shell command. Please follow installation instructions at https://nextstrain.org/docs/ and try again.")
        sys.exit(1)


def get_todays_date():
    date = datetime.datetime.today().strftime('%Y-%m-%d')
    return date

base_dir = "/data/PROJETS/COVID-19_Epidemio/Vison/"
script_dir = "/data/Applications/GitScript/Covid19_V2/NextStrainFiles/scripts/"
tool_dir = "/data/Applications/GitScript/Covid19_V2/NextStrainFiles/tools/"

#TODO choose here
#align_out_dir = os.path.join(base_dir,"alignment_results_mink_and_mink_to_human")
align_out_dir = os.path.join(base_dir,"alignment_results_mink_to_human_only")

gisaid_fasta_all = os.path.join(base_dir,"sequences_2020-11-12_07-33.fasta")
reference = os.path.join(base_dir,"reference.gb")
gisaid_fasta_mink = os.path.join(base_dir,"gisaid_extract_temp.fasta")
metadata_all = os.path.join(base_dir,"metadata_2020-11-12_10-27.tsv")
pd_metadata_all = pd.read_csv(metadata_all,sep="\t",index_col=False)

pd_metadata_mink = pd_metadata_all.loc[pd_metadata_all['host'] == 'Neovison vison',:].copy()

gisaid_mink_to_human = ['EPI_ISL_461190','EPI_ISL_461192','EPI_ISL_461200','EPI_ISL_461202','EPI_ISL_461203',
'EPI_ISL_522987','EPI_ISL_523034','EPI_ISL_523040','EPI_ISL_523046','EPI_ISL_523068','EPI_ISL_523070','EPI_ISL_523072',
'EPI_ISL_523073','EPI_ISL_523075','EPI_ISL_523085','EPI_ISL_523089','EPI_ISL_523120','EPI_ISL_523282','EPI_ISL_523286','EPI_ISL_523301',
'EPI_ISL_523310','EPI_ISL_523312','EPI_ISL_523333','EPI_ISL_523493','EPI_ISL_523494']


pd_metadata_mink_to_human = pd_metadata_all.loc[pd_metadata_all['gisaid_epi_isl'].isin(gisaid_mink_to_human),:].copy()


#TODO choose here 
pd_all = pd.concat([pd_metadata_mink_to_human])
#pd_all = pd.concat([pd_metadata_mink_to_human,pd_metadata_mink])


for index,row in pd_all.iterrows():
    strain = str(row['strain'])
    #print(strain)
    subprocess.call(["seqkit","grep","-r","-p","^" + str(strain),gisaid_fasta_all],stdout=open(gisaid_fasta_mink,"a"))

rule files: 
    params:
        reference = reference,
        to_align =  gisaid_fasta_mink

files = rules.files.params

#print(files.reference)


checkpoint partition_sequences:
    input:
        sequences = files.to_align
    output:
        split_sequences = directory(os.path.join(align_out_dir,"split_sequences/pre/"))
    params:
        sequences_per_group = 50,
        script_dir = script_dir
    shell:
        """
        python3 {params.script_dir}partition-sequences.py \
            --sequences {input.sequences} \
            --sequences-per-group {params.sequences_per_group} \
            --output-dir {output.split_sequences}
        """

rule partitions_intermediate:
    message:
        """
        partitions_intermediate: Copying sequence fastas
        {wildcards.cluster}
        """
    input:
        os.path.join(align_out_dir,"split_sequences/pre/{cluster}.fasta")
    output:
        os.path.join(align_out_dir,"split_sequences/post/{cluster}.fasta")
    shell:
        "cp {input} {output}"

rule align:
    message:
        """
        Aligning sequences to {input.reference}
          - gaps relative to reference are considered real
        Cluster:  {wildcards.cluster}
        """
    input:
        sequences = rules.partitions_intermediate.output,
        reference = files.reference
    output:
        alignment = os.path.join(align_out_dir,"split_alignments/{cluster}.fasta")
    threads: -1
    shell:
        """
        augur align \
            --sequences {input.sequences} \
            --reference-sequence {input.reference} \
            --output {output.alignment} \
            --nthreads auto \
            --remove-reference \
            --fill-gaps
        """

def _get_alignments(wildcards):
    checkpoint_output = checkpoints.partition_sequences.get(**wildcards).output[0]
    return expand(os.path.join(align_out_dir,"split_alignments/{i}.fasta"),
                  i=glob_wildcards(os.path.join(checkpoint_output, "{i}.fasta")).i)

rule aggregate_alignments:
    message: "Collecting alignments"
    input:
        alignments = _get_alignments
    output:
        alignment = os.path.join(align_out_dir,"aligned.fasta")
    shell:
        """
        cat {input.alignments} > {output.alignment}
        """

rule mask:
    message:
        """
        Mask bases in alignment
          - masking {params.mask_from_beginning} from beginning
          - masking {params.mask_from_end} from end
          - masking other sites: {params.mask_sites}
        """
    input:
        alignment = rules.aggregate_alignments.output.alignment
    output:
        alignment = os.path.join(align_out_dir,"masked.fasta")
    params:
        mask_from_beginning = 100,
        mask_from_end = 50,
        mask_sites = "18529 29849 29851 29853",
        script_dir = script_dir
    shell:
        """
        python3 {params.script_dir}mask-alignment.py \
            --alignment {input.alignment} \
            --mask-from-beginning {params.mask_from_beginning} \
            --mask-from-end {params.mask_from_end} \
            --mask-sites {params.mask_sites} \
            --output {output.alignment}
        """

rule print_seq_length:
    message:
        """
        Print seq length
        """
    input :
        align_file = rules.mask.output.alignment,
        fasta_temp = gisaid_fasta_mink
    output: 
        out_file = os.path.join(align_out_dir,"seq_length.txt")
    params:
        script_dir = tool_dir
    shell:
        """
        python3 {params.script_dir}GetSeqLength.py \
            --alignment {input.align_file} \
            --output {output.out_file} \

        rm {input.fasta_temp}
        """ 
